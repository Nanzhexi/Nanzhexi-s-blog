---
title: 深入浅出谈谈fork()函数
categories: 操作系统
date: 2023-04-14
---
一个进程，包括代码、数据和分配给进程的资源。ok()函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两
个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。
一个进程调用ok()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新
的新进程中，只有少数值与原来的进程的值不同。
上面的话通俗理解就是：fok是复制进程的函数，程序一开始就会产生一个进程，当这个进程（代码执行到fork()时，fok就会复制一份原来
的进程即就是创建一个新进程，我们称子进程，而原来的进程我们称为父进程，此时父子进程是共存的，他们一起向下执行代码。
注意的一点：就是调用fok函数Q之后，一定是两个进程同时执行fork函数之后的代码，而之前的代码以及由父进程执行完毕。
fork的特点：
首先明白linux中：
PID表示的进程号，是唯一的，一个PD只标识一个进程
PCB:进程控制块，进程控制块是用一个结构体struct task_struct来实现
![ixK1oa.jpeg](https://i.328888.xyz/2023/04/14/ixK1oa.jpeg)
fork的返回值问题：
在父进程中，fok返回新创建子进程的进程ID;
在子进程中，fork返回0；
如果出现错误，fok返回一个负值；
getppid(O:得到一个进程的父进程的PID;
getpid():得到当前进程的PID;
*注意：在fok函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fok函数返回
0,在父进程中，fok返回新创建子进程的进程ID。我们可以通过fok返回的值来判断当前进程是子进程还是父进程。
fok是把已有的进程复制一份，当然把PCB也复制了一份，然后申请一个PID
子进程的PID=父进程的PID+1;
![ixLDc5.jpeg](https://i.328888.xyz/2023/04/14/ixLDc5.jpeg)
**第一次看的时候非常的奇怪，一个函数返回两次？是的，在调用fok后，fok函数后面的所有代码会执行两遍**
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
/**
 *最基础的fork例子
 **/
int main(int argc, char const *argv[])
{
    pid_t pid;
    //判断1
    if ((pid=fork()) < 0)
    {
        perror("fork error");
    }
    //判断2
    else if (pid == 0)//子进程
    {
         printf("child getpid()=%d\n", getpid());
    }
    //判断3
    else if(pid > 0)//父进程
    {
        printf("parent getpid()=%d\n", getpid());
    }
 
    return 0;
}
```
结果如下
```
parent getpid()=13725
child getpid()=13726
```
两个判断的代码都执行了，这是非常不可思议的，但fok函数确实实现了这样的功能。也就是在fok函数后面的代码都会执行2遍。这就
是为什么两个判断都会被执行的原因。
现在来梳理一下成功fok的执行流程
第一步：pid=fork0,如果成功那么pid就有一个非0正值。否则返回-1。
第二步：因为pid>0,所以进入判断3。这是在父进程。
第三步：父进程的代码执行完了，程序又会把fok后面的函数再执行一遍，此时pid的值变为0，所以进入判断2。
*注意：这里的pid t类似一个类型，就像it型一样，in型定义的变量都是整型的，pidt定义的类型都是进程号类型。这个语句的意思是
定义了一个pid类型的变量pid,fork()函数返回一个进程号，这个进程号赋给了pid。pid_t在头文件types.h(sys/types.h)中定义
pid_就是一个short类型变量，实际表示的是内核中的进程表的索引

